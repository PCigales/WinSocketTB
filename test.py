from SocketTB import *
import ssl
import base64
import os
import threading
import io
import time
import locale
import email.utils
import webbrowser
import msvcrt

with ISocketGenerator() as IGen:
  ISock0 = IGen(family=socket.AF_INET, type=socket.SOCK_STREAM)
  sock2 = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
  ISock2 = IGen(sock2)
  ISock0.bind(('127.0.0.1', 9000))
  ISock0.listen()
  ISock2.connect(('127.0.0.1', 9000))
  ISock1 = ISock0.accept()[0]
  print(ISock0, ISock1, ISock2)
  ISock2.sendall(b'test')
  print(ISock1.recv(10))
  try:
    ISock1.recv(10, timeout=2)
  except TimeoutError:
    print('timeout')
  def r(n):
    try:
      ISock1.recv(n)
    except OSError as err:
      if err.winerror == 10038:
        print('interrupted')
      else:
        raise
  t = threading.Thread(target=r, args=(10, ))
  t.start()
  time.sleep(2)
  ISock1.shutclose()
  def a():
    try:
      ISock1 = ISock0.accept()[0]
    except OSError as err:
      if err.winerror == 10038:
        print('interrupted')
      else:
        raise
  t = threading.Thread(target=a)
  t.start()
  time.sleep(2)

with IDSocketGenerator() as IDGen:
  IDSock0 = IDGen(family=socket.AF_INET, type=socket.SOCK_STREAM)
  sock2 = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
  IDSock2 = IDGen(sock2)
  IDSock0.bind(('127.0.0.1', 9000))
  IDSock0.listen()
  IDSock2.connect(('127.0.0.1', 9000))
  IDSock1 = IDSock0.accept()[0]
  print(IDSock0, IDSock1, IDSock2)
  IDSock2.sendall(b'test2')
  IDSock1.sendall(b'test1')
  print(IDSock1.recv(10))
  print(IDSock2.recv(10))
  def r1(n):
    try:
      IDSock1.recv(n)
    except OSError as err:
      if err.winerror == 10038:
        print('interrupted1')
      else:
        raise
  def r2(n):
    try:
      IDSock2.recv(n)
    except OSError as err:
      if err.winerror == 10038:
        print('interrupted2')
      else:
        raise
  t1 = threading.Thread(target=r1, args=(10, ))
  t2 = threading.Thread(target=r2, args=(10, ))
  t1.start()
  t2.start()
  time.sleep(2)

ctxs = NestedSSLContext(ssl.PROTOCOL_TLS_SERVER)
ctxs.load_autogenerated_cert_chain()
ctxc = NestedSSLContext(ssl.PROTOCOL_TLS_CLIENT)
ctxc.check_hostname = False
ctxc.verify_mode = ssl.CERT_NONE
with IDSocketGenerator() as IDGen:
  IDSock0 = IDGen(family=socket.AF_INET, type=socket.SOCK_STREAM)
  IDSock2 = IDGen(family=socket.AF_INET, type=socket.SOCK_STREAM)
  IDSock0S = ctxs.wrap_socket(IDSock0, server_side=True)
  IDSock0SS = ctxs.wrap_socket(IDSock0S, server_side=True)
  IDSock2S = ctxc.wrap_socket(IDSock2, server_side=False, server_hostname='127.0.0.1')
  IDSock2SS = ctxc.wrap_socket(IDSock2S, server_side=False, server_hostname='127.0.0.1')
  IDSock0SS.bind(('127.0.0.1', 9000))
  IDSock0SS.listen()
  def c():
    IDSock2SS.connect(('127.0.0.1', 9000))
  t = threading.Thread(target=c)
  t.start()
  IDSock1SS = IDSock0SS.accept()[0]
  print(IDSock0SS, IDSock1SS, IDSock2SS)
  IDSock2SS.sendall(b'test')
  print(IDSock1SS.recv(10))
  IDSock0SS.shutclose()
  IDSock1SS.shutclose()
  IDSock2SS.shutclose()
print(IDSock0SS, IDSock1SS, IDSock2SS)

UDPServer = MultiUDPIServer(1900, RequestHandler, True, ('239.255.255.250', 'ff02::c'))
UDPServer.start()
with ISocketGenerator() as IGen:
  ISock0 = IGen(family=socket.AF_INET, type=socket.SOCK_DGRAM)
  ISock0.sendto(b'test ipv4', ('239.255.255.250', 1900))
  ISock0.close()
  ISock0 = IGen(family=socket.AF_INET6, type=socket.SOCK_DGRAM)
  ISock0.sendto(b'test ipv6', ('ff02::c', 1900))
  ISock0.close()
  ISock0 = IGen(family=socket.AF_INET6, type=socket.SOCK_DGRAM)
  ISock0.bind(('::1',0))
  ISock0.sendto(b'test ipv6 lb', ('ff02::c', 1900))
time.sleep(2)
UDPServer.shutdown()

DS = WebSocketDataStore()
ctxs = NestedSSLContext(ssl.PROTOCOL_TLS_SERVER)
cid = base64.b32encode(os.urandom(10)).decode('utf-8')
with RSASelfSigned('TCPIServer' + cid, 1) as cert:
  cert.pipe_PEM('cert' + cid, 'key' + cid, 2)
  ctxs.load_cert_chain(r'\\.\pipe\cert%s.pem' % cid, r'\\.\pipe\key%s.pem' % cid)
WSSServer = WebSocketIDServer(('127.0.0.1', 9000), nssl_context=ctxs)
WSSServer.start()
WSSServer.open('/test')
WSSClient = WebSocketIDClient('wss://127.0.0.1:9000/test', DS)
WSSServer.broadcast('/test', 'welcome')
time.sleep(0.5)
print(DS.incoming)
WSSClient.close()
WSSServer.close('/test')
WSSServer.stop()

with IDSocketGenerator() as IDGen:
  HTTPRequest = HTTPRequestConstructor(IDGen)
  rep = HTTPRequest('https://www.python.org')
  print(rep)
  pcon = []
  rep = HTTPRequest('https://www.python.org', max_length=-1, pconnection=pcon)
  print(pcon)
  print(rep.body(20))
  print(rep.body(20))
  pcon[0].shutclose()
  rep = HTTPRequest('http://www.google.fr/search', max_length=-1, pconnection=pcon, process_cookies=True)
  print(pcon)
  print(rep.body(20))
  pcon[0].shutclose()

BA = HTTPBasicAuthenticator()
with HTTPIServer(9000, '', threaded=True, max_upload_size=10, dual_stack=True, basic_auth=BA), IDAltSocketGenerator() as IDGen:
  BA.set_realm('/', 'root')
  BA.set_credential('user', 'password', 'root')
  IDSock0 = IDGen(family=socket.AF_INET)
  IDSock0.connect(('127.0.0.1', 9000))
  IDSock0.send(b'OPTIONS * HTTP/1.1\r\nHost: 127.0.0.1:9000\r\n\r\n')
  print(IDSock0.recv(1024))
  IDSock0.close()
  IDSock0 = IDGen(family=socket.AF_INET6)
  IDSock0.connect(('[::1]', 9000))
  IDSock0.send(b'OPTIONS * HTTP/1.1\r\nHost: [::1]:9000\r\n\r\n')
  print(IDSock0.recv(1024))
  IDSock0.close()
  HTTPRequest = HTTPRequestConstructor(IDGen)
  pcon = []
  print(HTTPRequest('http://localhost:9000/*', method='OPTIONS', pconnection=pcon))
  print(HTTPRequest('http://localhost:9000/', pconnection=pcon))
  print(pcon)
  print(HTTPRequest('http://localhost:9000/', pconnection=pcon, basic_auth='user:password'))
  BA.set_realm('/', None)
  print(HTTPRequest('http://localhost:9000/nul', method='PUT', data=b'0' * 11, pconnection=pcon))
  print(pcon)
  u = HTTPIUpload('http://localhost:9000/nul', data=b'0' * 18)
  u.start()
  print(u.wait_finish(), u.progress['error'])
  u = HTTPIUpload('http://localhost:9000/nul', data=b'0' * 8)
  u.start()
  print(u.wait_finish())
  b = io.BytesIO()
  with HTTPIDownload('http://localhost:9000/test.py', b, max_workers=3, timeout=5, section_min=2, block_size=2) as d:
    while int(d.wait_progression().rstrip(' %')) <= 25:
      print(d.wait_sections(0))
    d.stop()
  print(d)
  with HTTPIDownload('http://localhost:9000/test.py', b, max_workers=2, timeout=5, section_min=4, block_size=4, resume=d) as d:
    while d.wait_finish(0) not in ('completed', 'aborted'):
      print(d.wait_sections())
    print(d)
  print(len(b.getvalue()))
  b.close()

locale.setlocale(locale.LC_TIME, '')
with NTPClient('time.google.com') as ntpc:
  print(ntpc.get_time(to_local=True))
  print(ntpc.get_offset())

with TOTPassword('AAAAAAAAAAAAAAAA') as totp:
  for i in range(10):
    p, r = totp.get(clipboard=True)
    print('', p, str(r).rjust(4), end ='\b'*12, flush=True)
    time.sleep(1)
  print('')

body1 = \
  '  <!DOCTYPE h\tml>\r\n' \
  '  <html lang="en">\r\n' \
  '    <head>\r\n' \
  '      <meta charset="utf-8">\r\n' \
  '      <title>WebRTC DataChannel</title>\r\n' \
  '      <style>\r\n' \
  '        body {\r\n' \
  '          width: 100vw;\r\n' \
  '          height: 100vh;\r\n' \
  '          margin:0;\r\n' \
  '          --number: 1;\r\n' \
  '        }\r\n' \
  '        iframe {\r\n' \
  '          display: block;\r\n' \
  '          box-sizing: border-box;\r\n' \
  '          width: 100%;\r\n' \
  '          height: calc(100% / var(--number));\r\n' \
  '        };\r\n' \
  '      </style>\r\n' \
  '      <style id="style" type="text/css-iframe">\r\n' \
  '        ul {\r\n' \
  '          margin: 0;\r\n' \
  '          padding: 0.5em;\r\n' \
  '          list-style: inside disclosure-closed;\r\n' \
  '          white-space: pre;\r\n' \
  '        }\r\n' \
  '        h2 {\r\n' \
  '          display: block;\r\n' \
  '          margin: 0;\r\n' \
  '        }\r\n' \
  '        h3 {\r\n' \
  '          display: inline-block;\r\n' \
  '          margin-block: 0.2em;\r\n' \
  '        }\r\n' \
  '        input, span {\r\n' \
  '          width: 100em;\r\n' \
  '          margin: 0.5em;\r\n' \
  '          vertical-align: text-bottom;\r\n' \
  '          font-size: 1em;\r\n' \
  '        }\r\n' \
  '        span {\r\n' \
  '          margin-inline: 1em;\r\n' \
  '        }\r\n' \
  '        li {\r\n' \
  '          margin-left: 1em;\r\n' \
  '        }\r\n' \
  '      </style>\r\n' \
  '      <script id="script" type="text/js-iframe">\r\n' \
  '        "use strict";\r\n' \
  '        const WebRTCDataChannelSignaler = Inherits(function constructor(path, name, config, target) {\r\n' \
  '          return SuperDerivedConstructor(this, new.target, target, constructor, path, name, config);\r\n' \
  '        }, WebRTCSignaler);\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onopenhandler = function () {\r\n' \
  '          SuperMethod(WebRTCDataChannelSignaler, "onopenhandler", this);\r\n' \
  '          const peers = document.createElement("ul");\r\n' \
  '          peers.id = `peers ${this.name}`;\r\n' \
  '          const name = document.createElement("h2");\r\n' \
  '          name.appendChild(document.createTextNode(decodeURIComponent(this.name)));\r\n' \
  '          peers.appendChild(name);\r\n' \
  '          peers.appendChild(document.createElement("input"));\r\n' \
  '          document.body.appendChild(peers);\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onerrorhandler = function () {\r\n' \
  '          SuperMethod(WebRTCDataChannelSignaler, "onerrorhandler", this);\r\n' \
  '          const peers = document.getElementById(`peers ${this.name}`);\r\n' \
  '          if (peers) {\r\n' \
  '            document.body.removeChild(peers);\r\n' \
  '          }\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onclosehandler = function () {\r\n' \
  '          SuperMethod(WebRTCDataChannelSignaler, "onclosehandler", this);\r\n' \
  '          const peers = document.getElementById(`peers ${this.name}`);\r\n' \
  '          if (peers) {\r\n' \
  '            document.body.removeChild(peers);\r\n' \
  '          }\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onpeeraddhandler = function (name) {\r\n' \
  '          SuperMethod(WebRTCDataChannelSignaler, "onpeeraddhandler", this, name);\r\n' \
  '          const peers = document.getElementById(`peers ${this.name}`);\r\n' \
  '          const cpeer = document.createElement("li");\r\n' \
  '          const peer = document.createElement("h3");\r\n' \
  '          peer.id = `peer ${this.name} ${encodeURIComponent(name)}`;\r\n' \
  '          peer.appendChild(document.createTextNode(name));\r\n' \
  '          peer.style.cursor = "alias";\r\n' \
  '          peer.onclick = this.onpeerclickhandler.bind(this);\r\n' \
  '          cpeer.appendChild(peer);\r\n' \
  '          cpeer.appendChild(document.createElement("span"));\r\n' \
  '          peers.insertBefore(cpeer, Array.prototype.find.call(peers.getElementsByTagName("h3"), (e) => e.innerText > name)?.parentElement ?? null);\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onpeerremovehandler = function (name) {\r\n' \
  '          SuperMethod(WebRTCDataChannelSignaler, "onpeerremovehandler", this, name);\r\n' \
  '          const peer = document.getElementById(`peer ${this.name} ${encodeURIComponent(name)}`);\r\n' \
  '          if (peer) {document.getElementById(`peers ${this.name}`).removeChild(peer.parentElement);}\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onchannelopenhandler = function ({target:channel}) {\r\n' \
  '          const peer = document.getElementById(`peer ${channel.label}`);\r\n' \
  '          peer.style.pointerEvents = "";\r\n' \
  '          channel.send(`[${(new Date()).toLocaleString()}]\\u00a0\\u00a0${peer.parentElement.parentElement.firstElementChild.nextElementSibling.value}`);\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onchannelmessagehandler = function ({target:channel, data}) {\r\n' \
  '          document.getElementById(`peer ${this.signaler.name} ${this.dest}`).parentElement.lastElementChild.textContent = data;\r\n' \
  '          if (! data.startsWith("[ok]")) {channel.send("[ok] " + data)};\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onchannelclosehandler = function ({target:channel}) {\r\n' \
  '          this.close();\r\n' \
  '          this.onconnectionstatechangehandler("closed");\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onpeerclickhandler = function ({currentTarget}) {\r\n' \
  '          const name = currentTarget.id.split(" ")[2];\r\n' \
  '          if (this.connections.has(name)) {\r\n' \
  '            const connection = this.connections.get(name);\r\n' \
  '            connection.channel.send(`[${(new Date()).toLocaleString()}]\\u00a0\\u00a0${currentTarget.parentElement.parentElement.firstElementChild.nextElementSibling.value}`);\r\n' \
  '          } else {\r\n' \
  '            const connection = this.connection(decodeURIComponent(name));\r\n' \
  '            if (! connection) {return;}\r\n' \
  '            const channel = connection.createDataChannel(`${this.name} ${name}`);\r\n' \
  '            channel.onopen = this.onchannelopenhandler.bind(connection);\r\n' \
  '            channel.onmessage = this.onchannelmessagehandler.bind(connection);\r\n' \
  '            channel.onclose = this.onchannelclosehandler.bind(connection);\r\n' \
  '            connection.channel = channel;\r\n' \
  '          }\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.connection = function (dest) {\r\n' \
  '          const connection =  SuperMethod(WebRTCDataChannelSignaler, "connection", this, dest);\r\n' \
  '          if (connection) {document.getElementById(`peer ${this.name} ${encodeURIComponent(dest)}`).style.pointerEvents = "none";}\r\n' \
  '          return connection;\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onconnectiondatachannelhandler = function (channel) {\r\n' \
  '          const signaler = this.signaler;\r\n' \
  '          const peer = document.getElementById(`peer ${signaler.name} ${this.dest}`);\r\n' \
  '          peer.style.pointerEvents = "";\r\n' \
  '          channel.onmessage = signaler.onchannelmessagehandler.bind(this);\r\n' \
  '          channel.onclose = signaler.onchannelclosehandler.bind(this);\r\n' \
  '          this.channel = channel;\r\n' \
  '        };\r\n' \
  '        WebRTCDataChannelSignaler.prototype.onconnectionstatechangehandler = function handler(state, infos) {\r\n' \
  '          const peer = document.getElementById(`peer ${this.signaler.name} ${this.dest}`);\r\n' \
  '          if (! peer) {return;}\r\n' \
  '          if (state == "connected") {\r\n' \
  '            const inf = infos ?? this.infos;\r\n' \
  '            if (inf) {\r\n' \
  '              peer.title = Object.entries(inf).map((e) => e.join(": ")).join("\\r\\n");\r\n' \
  '            } else if (! infos) {\r\n' \
  '              const connection = this;\r\n' \
  '              this.infos2.then(function (inf) {handler.call(connection, connection.connectionState, inf);});\r\n' \
  '            }\r\n' \
  '          } else {\r\n' \
  '            peer.title = "";\r\n' \
  '          }\r\n' \
  '        }\r\n' \
  '        const server = parent.server;\r\n' \
  '        const name = document.currentScript.id;\r\n' \
  '        var signaler = null;\r\n' \
  '        WebRTCDataChannelSignaler.acquire(`${server.secure ? "https" : "http"}://${server.address}`, "test", `<${name}>`, "WebRTC", name).then(function (server) {signaler = server == Null ? null : server;});\r\n' \
  '      </script>\r\n' \
  '    </head>\r\n' \
  '    <body>\r\n' \
  '      <script>\r\n' \
  '        var server = {address: "127.0.0.1:9000", secure: location.protocol.endsWith("s:")};\r\n' \
  '        let number = 3;\r\n' \
  '        const url_script = URL.createObjectURL(new Blob([document.getElementById("script").textContent],{type: "text/javascript"}));\r\n' \
  '        const url_style = URL.createObjectURL(new Blob([document.getElementById("style").textContent],{type: "text/css"}));\r\n' \
  '        document.body.style.setProperty("--number", number);\r\n' \
  '        for (let i=0; i<number; i++) {\r\n' \
  '          const frame = document.createElement("iframe");\r\n' \
  '          frame.srcdoc = `\\<link rel="stylesheet" href="${url_style}"/\\>\\<script src="${server.secure ? "https" : "http"}://${server.address}/script.js" onerror="window.stop()"\\>\\</script\\>\\<script id="${String.fromCharCode(65 + i)}" src="${url_script}"\\>\\</script\\>`;\r\n' \
  '          frame.onload = function () {if (--number == 0) {URL.revokeObjectURL(url_script); URL.revokeObjectURL(url_style);}}\r\n' \
  '          document.body.appendChild(frame);\r\n' \
  '        }\r\n' \
  '      </script>\r\n' \
  '    </body>\r\n' \
  '  </html>\r\n' \
  .encode('utf-8')
body2 = \
  '<!DOCTYPE html>\r\n' \
  '<html lang="en">\r\n' \
  '  <head>\r\n' \
  '    <meta charset="utf-8">\r\n' \
  '    <title>WebRTC DataChannel</title>\r\n' \
  '    <style>\r\n' \
  '      body {\r\n' \
  '        width: 100vw;\r\n' \
  '        height: 100vh;\r\n' \
  '        margin:0;\r\n' \
  '      }\r\n' \
  '      iframe {\r\n' \
  '        display: block;\r\n' \
  '        box-sizing: border-box;\r\n' \
  '        width: 100%;\r\n' \
  '        height: 50%;\r\n' \
  '      };\r\n' \
  '    </style>\r\n' \
  '    <style id="style" type="text/css-iframe">\r\n' \
  '      body {\r\n' \
  '        margin: 0;\r\n' \
  '      }\r\n' \
  '      input {\r\n' \
  '        width: calc (100vw - 1em);\r\n' \
  '        height: 2em;\r\n' \
  '        margin: 0.5em;\r\n' \
  '        font-size: 1em;\r\n' \
  '      }\r\n' \
  '      video {\r\n' \
  '        display: block;\r\n' \
  '        margin: 0.5em;\r\n' \
  '        max-width: calc(100vw - 1em);\r\n' \
  '        height: calc(100vh - 4em);\r\n' \
  '      }\r\n' \
  '    </style>\r\n' \
  '    <script id="script_e" type="text/js-iframe">\r\n' \
  '      "use strict";\r\n' \
  '      const WebRTCMediaStreamSignaler = Inherits(function constructor(path, name, config, target) {\r\n' \
  '        return SuperDerivedConstructor(this, new.target, target, constructor, path, name, config);\r\n' \
  '      }, WebRTCSignaler);\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onopenhandler = function () {\r\n' \
  '        SuperMethod(WebRTCMediaStreamSignaler, "onopenhandler", this);\r\n' \
  '        document.getElementById("file").onchange = this.onvideochangehandler.bind(this);\r\n' \
  '        document.getElementById("video").onplay = this.onvideoplayhandler.bind(this);\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onerrorhandler = function () {\r\n' \
  '        SuperMethod(WebRTCMediaStreamSignaler, "onerrorhandler", this);\r\n' \
  '        document.getElementById("file").onchange = null;\r\n' \
  '        document.getElementById("video").onplay = null;\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onclosehandler = function () {\r\n' \
  '        SuperMethod(WebRTCMediaStreamSignaler, "onclosehandler", this);\r\n' \
  '        document.getElementById("file").onchange = null;\r\n' \
  '        document.getElementById("video").onplay = null;\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onpeeraddhandler = function (name) {\r\n' \
  '        SuperMethod(WebRTCMediaStreamSignaler, "onpeeraddhandler", this, name);\r\n' \
  '        if (name == "r") {;\r\n' \
  '          document.getElementById("file").disabled = false;\r\n' \
  '        };\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onpeerremovehandler = function (name) {\r\n' \
  '        SuperMethod(WebRTCMediaStreamSignaler, "onpeerremovehandler", this, name);\r\n' \
  '        if (name == "r") {;\r\n' \
  '          document.getElementById("file").disabled = true;\r\n' \
  '          document.getElementById("video").src = "";\r\n' \
  '          document.getElementById("video").controls = false;\r\n' \
  '        };\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onvideochangehandler = function({target: {files: [file]}}) {\r\n' \
  '        const connection = this.connections.get("r");\r\n' \
  '        if (connection) {\r\n' \
  '          connection.getSenders().forEach(function (sender) {connection.removeTrack(sender);});\r\n' \
  '        }\r\n' \
  '        document.getElementById("video").src = URL.createObjectURL(file);\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onvideoplayhandler = function ({target: video}) {\r\n' \
  '        const connection = this.connections.get("r") ?? this.connection("r");\r\n' \
  '        if (! connection || connection.getSenders().filter(({track}) => track?.readyState == "live").length) {return;}\r\n' \
  '        video.controls = true;\r\n' \
  '        const stream = (video.captureStream ?? video.mozCaptureStream).call(video);\r\n' \
  '        if (video.mozCaptureStream && stream.getAudioTracks().length) {\r\n' \
  '          const ctx = new AudioContext()\r\n' \
  '          ctx.createMediaStreamSource(stream).connect(ctx.destination);\r\n' \
  '        }\r\n' \
  '        const asenders = connection.getSenders().filter(({track}) => track?.readyState == "ended").values();\r\n' \
  '        stream.getTracks().forEach(function (track) {\r\n' \
  '          const sender = asenders.next().value;\r\n' \
  '          if (sender) {\r\n' \
  '            sender.replaceTrack(track);\r\n' \
  '          } else {\r\n' \
  '            connection.addTrack(track, stream);\r\n' \
  '          }\r\n' \
  '        });\r\n' \
  '      };\r\n' \
  '      const server = parent.server;\r\n' \
  '      var signaler = null;\r\n' \
  '      WebRTCMediaStreamSignaler.acquire(`${server.secure ? "https" : "http"}://${server.address}`, "test", "e", "WebRTC").then(function (server) {signaler = server == Null ? null : server;});\r\n' \
  '    </script>\r\n' \
  '    <script id="script_r" type="text/js-iframe">\r\n' \
  '      "use strict";\r\n' \
  '      const WebRTCMediaStreamSignaler = Inherits(function constructor(path, name, config, target) {\r\n' \
  '        return SuperDerivedConstructor(this, new.target, target, constructor, path, name, config);\r\n' \
  '      }, WebRTCSignaler);\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onpeerremovehandler = function (name) {\r\n' \
  '        SuperMethod(WebRTCMediaStreamSignaler, "onpeerremovehandler", this, name);\r\n' \
  '        if (name == "e") {;\r\n' \
  '          document.getElementById("video").srcObject = null;\r\n' \
  '        };\r\n' \
  '      };\r\n' \
  '      WebRTCMediaStreamSignaler.prototype.onconnectiontrackhandler = function (track, [stream]) {\r\n' \
  '        document.getElementById("video").srcObject = stream;\r\n' \
  '      };\r\n' \
  '      const server = parent.server;\r\n' \
  '      var signaler = null;\r\n' \
  '      WebRTCMediaStreamSignaler.acquire(`${server.secure ? "https" : "http"}://${server.address}`, "test", "r", "WebRTC").then(function (server) {signaler = server == Null ? null : server;});\r\n' \
  '    </script>\r\n' \
  '  </head>\r\n' \
  '  <body>\r\n' \
  '    <iframe id="frame_e"></iframe>\r\n' \
  '    <iframe id="frame_r"></iframe>\r\n' \
  '    <script>\r\n' \
  '      var server = {address: "192.168.1.12:9000", secure: location.protocol.endsWith("s:")};\r\n' \
  '      const url_script_e = URL.createObjectURL(new Blob([document.getElementById("script_e").textContent],{type: "text/javascript"}));\r\n' \
  '      const url_script_r = URL.createObjectURL(new Blob([document.getElementById("script_r").textContent],{type: "text/javascript"}));\r\n' \
  '      const url_style = URL.createObjectURL(new Blob([document.getElementById("style").textContent],{type: "text/css"}));\r\n' \
  '      const frame_e = document.getElementById("frame_e");\r\n' \
  '      frame_e.srcdoc = `\\<link rel="stylesheet" href="${url_style}"/\\>\\<script src="${server.secure ? "https" : "http"}://${server.address}/script.js" onerror="window.stop()"\\>\\</script\\>\\<input type="file" id="file" name="file" accept="video/*" disabled\\>\\<video id="video" playsinline autoplay onload="URL.revokeObjectURL(this.src)"\\>\\</video\\>\\<script src="${url_script_e}"\\>\\</script\\>`;\r\n' \
  '      frame_e.onload = function () {URL.revokeObjectURL(url_script_e);};\r\n' \
  '      const frame_r = document.getElementById("frame_r");\r\n' \
  '      frame_r.srcdoc = `\\<link rel="stylesheet" href="${url_style}"/\\>\\<script src="${server.secure ? "https" : "http"}://${server.address}/script.js" onerror="window.stop()"\\>\\</script\\>\\<video id="video" playsinline autoplay\\>\\</video\\>\\<script src="${url_script_r}"\\>\\</script\\>`;\r\n' \
  '      frame_r.onload = function () {URL.revokeObjectURL(url_script_r);};\r\n' \
  '    </script>\r\n' \
  '  </body>\r\n' \
  '</html>\r\n' \
  .encode('utf-8')
class TestRequestHandler(RequestHandler):
  def handle(self):
    if self.server.closed:
      return
    req = HTTPMessage(self.request)
    if req.method not in {'GET', 'HEAD'} or req.path.lower() != '/page.html':
      return
    resp = \
      'HTTP/1.1 200 OK\r\n' \
      'Date: %s\r\n' \
      'Server: SocketTB\r\n' \
      'Content-Length: %d\r\n' \
      'Content-Type: text/html; charset=utf-8\r\n' \
      'Connection: close\r\n' \
      '\r\n' % (email.utils.formatdate(time.time(), usegmt=True), len(body))
    self.request.sendall(resp.encode('ISO-8859-1'))
    if req.method != 'HEAD':
      self.request.sendall(body)
BA = WebRTCBasicAuthenticator()
code = BA.set_channel('test')
for n in 'ABCer':
  BA.set_credential(n, 'WebRTC', 'test')
for body in (body1, body2):
  with WebRTCSignalingServer(9000, basic_auth=BA) as SignalingServer, TCPIServer(9001, TestRequestHandler, threaded=True):
    SignalingServer.open('test')
    print('http://127.0.0.1:9001/page.html')
    webbrowser.open('http://127.0.0.1:9001/page.html')
    print('Press "S" to stop...')
    while True:
      k = msvcrt.getch()
      if k == b'\xe0':
        k = msvcrt.getch()
        k = b''
      if k.upper() == b'S':
        break
    SignalingServer.close('test')